package lpbcast;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Random;

import repast.simphony.context.Context;
import repast.simphony.engine.environment.RunEnvironment;
import repast.simphony.engine.schedule.ScheduledMethod;
import repast.simphony.parameter.Parameters;
import repast.simphony.space.continuous.ContinuousSpace;
import repast.simphony.space.graph.Network;
import repast.simphony.space.graph.RepastEdge;
import repast.simphony.util.ContextUtils;

/**
 * Class that defines a generic node of the system which will run the broadcast
 * algorithm.
 * 
 * It is assumed that, at each step, the node can probabilistically generate a
 * message and subscribe or unsubscribe.
 */
public class Node {
	// Variables for the simulation.
	private double PROBABILITY_GENERATE_MESSAGE;
	private double PROBABILITY_UNSUB;
	private double PROBABILITY_SUB;
	private int NUMBER_GOSSIP_SENDS;
	private int MAX_AGE_EVENTS;
	private int MAX_AGE_RETRANSMISSION;
	private int MAX_SIZE_VIEW;
	private int MAX_SIZE_SUBS;
	private int MAX_SIZE_UNSUBS;
	private int MAX_SIZE_EVENTS;
	private int MAX_SIZE_EVENTIDS;
	private int WAIT_ROUNDS_INITIAL;
	private int WAIT_ROUNDS_RANDOM;
	private int WAIT_ROUNDS_SOURCE;
	private boolean USE_AGE_BASED_PURGING;
	private boolean USE_RETRANSMISSION;
	private boolean USE_UNSUBSCRIPTIONS;
	private boolean USE_SINGLE_MESSAGE;

	private boolean DEBUG = true;

	// Variables for the node.
	public int id;
	public boolean isSubbed = true;
	public boolean sendingMessage = false; // Used to change color of the node in the visualization
	public boolean deliveringMessage = false; // Used to change color of the node in the visualization
	private int round = 0;
	private int nNodes = 1;
	private int nMessages = 0; // Number of sent messages
	private int nDeliveredMessages = 0; // Number of delivered messages
	private Router router;
	private ContinuousSpace<Object> space;
	private Random random = new Random();

	// Variables for the broadcast algorithm.
	private HashSet<Integer> view = new HashSet<Integer>();
	private HashSet<Integer> subs = new HashSet<Integer>();
	private HashSet<Integer> unSubs = new HashSet<Integer>();
	private HashSet<Event> events = new HashSet<Event>();
	private HashSet<EventToRetrieve> retrieveBuf = new HashSet<EventToRetrieve>();
	private LinkedList<Event> eventsForRetransmission = new LinkedList<Event>(); // List
																					// with
																					// all
																					// events

	// Generated by the node.
	private LinkedList<String> eventIds = new LinkedList<String>();

	/**
	 * Constructor of Node.
	 * 
	 * @param space  the space in which the node is added.
	 * @param id     the unique identifier of the node.
	 * @param router the router for messages.
	 */
	public Node(ContinuousSpace<Object> space, Router router, int id) {
		this.space = space;
		this.id = id;
		this.router = router;

		// Retrieve values from the simulation environment.
		Parameters p = RunEnvironment.getInstance().getParameters();
		PROBABILITY_GENERATE_MESSAGE = p.getDouble("PROBABILITY_GENERATE_MESSAGE");
		PROBABILITY_UNSUB = p.getDouble("PROBABILITY_UNSUB");
		PROBABILITY_SUB = p.getDouble("PROBABILITY_SUB");
		NUMBER_GOSSIP_SENDS = p.getInteger("NUMBER_GOSSIP_SENDS");
		MAX_AGE_EVENTS = p.getInteger("MAX_AGE_EVENTS");
		MAX_AGE_RETRANSMISSION = p.getInteger("MAX_AGE_RETRANSMISSION");
		MAX_SIZE_VIEW = p.getInteger("MAX_SIZE_VIEW");
		MAX_SIZE_SUBS = p.getInteger("MAX_SIZE_SUBS");
		MAX_SIZE_UNSUBS = p.getInteger("MAX_SIZE_UNSUBS");
		MAX_SIZE_EVENTS = p.getInteger("MAX_SIZE_EVENTS");
		MAX_SIZE_EVENTIDS = p.getInteger("MAX_SIZE_EVENTIDS");
		WAIT_ROUNDS_INITIAL = p.getInteger("WAIT_ROUNDS_INITIAL");
		WAIT_ROUNDS_RANDOM = p.getInteger("WAIT_ROUNDS_RANDOM");
		WAIT_ROUNDS_SOURCE = p.getInteger("WAIT_ROUNDS_SOURCE");
		USE_AGE_BASED_PURGING = p.getBoolean("USE_AGE_BASED_PURGING");
		USE_RETRANSMISSION = p.getBoolean("USE_RETRANSMISSION");
		USE_UNSUBSCRIPTIONS = p.getBoolean("USE_UNSUBSCRIPTIONS");
		USE_SINGLE_MESSAGE = p.getBoolean("USE_SINGLE_MESSAGE");
	}

	/**
	 * Initializes the system, so that every node knows another node.
	 * 
	 * The node picks some random nodes and inserts them into its view. It was
	 * decided to pick more than one node in order to reduce the probability of
	 * partition of the system at start time.
	 */
	public void initializeView() {
		// Get the number of nodes.
		Parameters p = RunEnvironment.getInstance().getParameters();
		nNodes = p.getInteger("NUMBER_NODES");

		// Add a maximum of three nodes as the initial view.
		for (int i = 0; i < Math.min(3, MAX_SIZE_VIEW); i++) {
			view.add(random.nextInt(nNodes));
		}
	}

	/**
	 * Executes a new time step.
	 */
	@ScheduledMethod(start = 1, interval = 1)
	public void step() {
		// Unsubscribe or re-subscribe probabilistically.
		subUnsub();

		if (isSubbed) {
			// Create a new message probabilistically.
			sendingMessage = false;
			deliveringMessage = false;
			generateMessage();

			// Increment the age of every event.
			incrementAges();

			// Send gossip messages.
			gossipEmission();

			// Ask for missing events.
			retrieveEvents();
		}

		round += 1;
	}

	/**
	 * Generates a new message probabilistically.
	 * 
	 * A message has id nodeId_nMessages, so that we are sure it is unique in the
	 * system. A created message is added to the events and eventsForRetransmission
	 * buffer.
	 */
	private void generateMessage() {
		if ((!USE_SINGLE_MESSAGE && random.nextDouble() <= PROBABILITY_GENERATE_MESSAGE)
				|| (USE_SINGLE_MESSAGE && round == 0 && id == 0)) {
			String eventId = id + "_" + nMessages + "_" + round;

			// Create a new event.
			Event e = new Event(id, eventId);
			print("Node " + id + " generated a message with id " + eventId + " at round " + round);
			events.add(new Event(e));
			eventsForRetransmission.add(e);
			sendingMessage = true;
			nMessages += 1;
			nDeliveredMessages += 1;

			// Purge the events buffer.
			purgeEvents();
		}
	}

	/**
	 * Sends a new gossip message to a subset of the view.
	 * 
	 * This method is called at each time step.
	 */
	private void gossipEmission() {
		// Generate the gossip message.
		GossipMessage gossip = new GossipMessage(events, eventIds, unSubs, subs, id);
		gossip.subs.add(id);

		// Send gossip message to NUMBER_GOSSIP_SENDS random members in the view.
		HashSet<Integer> sentTo = new HashSet<Integer>(); // For visualization purposes.
		ArrayList<Integer> viewList = new ArrayList<Integer>(view);
		Collections.shuffle(viewList); // Pick the nodes randomly.
		Iterator<Integer> itr = viewList.iterator();
		int nSend = NUMBER_GOSSIP_SENDS;
		while (itr.hasNext() && nSend > 0) {
			int currentNodeId = itr.next();

			// Avoid gossiping to self.
			if (currentNodeId != id) {
				router.send(gossip, currentNodeId);
				sentTo.add(currentNodeId);
				nSend -= 1;
			}
		}

		// Clear the events buffer.
		events.clear();

		// Show the emission in the network.
		clearNetwork("sentMessages network");
		buildNetwork(sentTo, "sentMessages network");
	}

	/**
	 * Handles an incoming gossip message.
	 * 
	 * @param gossip the gossip message received by the node.
	 */
	private void gossipReceive(GossipMessage gossip) {
		// Clear the networks.
		clearNetwork("view network");
		clearNetwork("subs network");
		clearNetwork("unsubs network");

		// -----------------------------------------------------
		// PHASE 1: Update view and unSubs with unsubscriptions.
		// -----------------------------------------------------

		// Handle the incoming unsubscriptions.
		Iterator<Integer> itrUnsubs = gossip.unSubs.iterator();
		while (itrUnsubs.hasNext()) {
			int current = itrUnsubs.next();
			view.remove(current);
			subs.remove(current);
			unSubs.add(current);
		}

		// Remove nodes from unSubs if the set is too big.
		unSubs = removeNodesFromSet(unSubs, MAX_SIZE_UNSUBS);

		// --------------------------------------------
		// PHASE 2: Update view with new subscriptions.
		// --------------------------------------------

		// Handle the incoming subscriptions.
		Iterator<Integer> itrSubs = gossip.subs.iterator();
		while (itrSubs.hasNext()) {
			int current = itrSubs.next();
			if (current != id && !view.contains(current)) {
				view.add(current);
				subs.add(current);
			}
		}

		// Remove nodes from view if the set is too big and add them to subs.
		ArrayList<Integer> listView = new ArrayList<Integer>(view);
		while (listView.size() > MAX_SIZE_VIEW) {
			Integer current = listView.get(random.nextInt(listView.size()));
			listView.remove(current);
			subs.add(current);
		}
		view = new HashSet<Integer>(listView);

		// Remove nodes from subs if the set is too big.
		subs = removeNodesFromSet(subs, MAX_SIZE_SUBS);

		// ----------------------------------------------
		// PHASE 3: update events with new notifications.
		// ----------------------------------------------

		// Handle the incoming events.
		Iterator<Event> itrEvents = gossip.events.iterator();
		while (itrEvents.hasNext()) {
			Event current = itrEvents.next();

			if (!eventIds.contains(current.eventId)) {
				// print("\t" + id + "\tGOSSIP:\t" + current.eventId);

				// Add the new event and deliver it.
				lpbDelivery(current);
			}
		}

		// Look for missing events.
		Iterator<String> itrEventIds = gossip.eventIds.iterator();
		while (itrEventIds.hasNext()) {
			String currentId = itrEventIds.next();
			int senderId = Integer.parseInt(currentId.split("_")[0]);
			if (!eventIds.contains(currentId) && senderId != this.id) {
				EventToRetrieve eventToFetch = new EventToRetrieve(currentId, round, gossip.sender);
				retrieveBuf.add(eventToFetch);
			}
		}
		// Remove too old eventIds
		List<EventToRetrieve> toBeRemoved = new LinkedList<EventToRetrieve>();
		for (EventToRetrieve s : retrieveBuf) {
			int generationRound = Integer.parseInt(s.eventId.split("_")[2]);
			if (round - generationRound > MAX_AGE_RETRANSMISSION) {
				toBeRemoved.add(s);
			}
		}
		retrieveBuf.removeAll(toBeRemoved);

		// Remove event IDs if their buffer is too full.
		while (eventIds.size() > MAX_SIZE_EVENTIDS) {
			// Remove the oldest event ID.
			eventIds.remove(0);
		}

		// Update the ages of already known events.
		for (Event eg : gossip.events) {
			for (Event e : events) {
				if (eg.eventId == e.eventId && e.age < eg.age) {
					e.age = eg.age;
				}
			}
		}

		// Remove events if their buffer is too full.
		purgeEvents();

		// Re-create the networks.
		buildNetwork(view, "view network");
		buildNetwork(subs, "subs network");
		buildNetwork(unSubs, "unsubs network");
	}

	/**
	 * Asks for events if the node didn't receive them in a certain amount of
	 * rounds.
	 * 
	 * Note that it is assumed that WAIT_ROUNDS_SOURCE > WAIT_ROUNDS_RANDOM >
	 * WAIT_ROUNDS_INITIAL.
	 */
	private void retrieveEvents() {
		Iterator<EventToRetrieve> itrRetEvnt = retrieveBuf.iterator();
		LinkedList<EventToRetrieve> eventsToRemove = new LinkedList<EventToRetrieve>();

		while (itrRetEvnt.hasNext()) {
			EventToRetrieve current = itrRetEvnt.next();
			if (!eventIds.contains(current.eventId)) {
				AskEventMessage e = new AskEventMessage(current.eventId, id);
				if (round - current.round == WAIT_ROUNDS_INITIAL) {
					// Ask to the gossip sender.
					// print("\t" + id + "\tASK SENDER\t" + current.eventId);
					router.send(e, current.gossipSender);
				} else if (round - current.round == WAIT_ROUNDS_RANDOM) {
					// Ask to a random node.
					// print("\t" + id + "\tASK RANDOM\t" + current.eventId);
					int rNode = random.nextInt(nNodes);
					router.send(e, rNode);
				} else if (round - current.round == WAIT_ROUNDS_SOURCE) {
					// Ask to the event source, assuming that event IDs are in form
					// nodeId_messageId.
					// print("\t" + id + "\tASK SOURCE\t" + current.eventId);
					int senderId = Integer.parseInt(current.eventId.split("_")[0]);
					router.send(e, senderId);
				}
			} else {
				eventsToRemove.add(current);
			}
		}
		retrieveBuf.removeAll(eventsToRemove);
	}

	/**
	 * Delivers an event.
	 * 
	 * The method just prints the eventId to the console.
	 * 
	 * @param e the event that has to be delivered.
	 */
	private void lpbDelivery(Event e) {
		if (!eventsForRetransmission.contains(e)) {
			deliveringMessage = true;
			events.add(new Event(e));
			print("Node " + id + " delivered message " + e.eventId + " at round " + round);
			nDeliveredMessages += 1;
			eventsForRetransmission.add(e);
			eventIds.add(e.eventId);
		}
	}

	/**
	 * Handles a generic incoming message.
	 * 
	 * The proper handler is called by checking the actual class of the message.
	 * 
	 * @param message the message received by the node.
	 */
	void receive(Message message) {
		// Accept gossip messages only if the node is subscribed.
		if (message instanceof GossipMessage && isSubbed) {
			gossipReceive((GossipMessage) message);
		} else if (message instanceof AskEventMessage) {
			sendRequestedEvent((AskEventMessage) message);
		} else if (message instanceof SendEventMessage) {
			receiveRequestedEvent((SendEventMessage) message);
		}
	}

	/**
	 * Handles an incoming request for a particular event.
	 * 
	 * If the node has the event, then it sends it back to the requester. It first
	 * checks in its event buffer and, if it does not find it, it searches in the
	 * buffer containing the events sent by the node itself.
	 * 
	 * @param message the message containing the request.
	 */
	public void sendRequestedEvent(AskEventMessage message) {
		Event toBeSent = null;
		LinkedList<Event> toBeRemoved = new LinkedList<Event>();

		// Look for the requested event and for obsolete ones.
		Iterator<Event> retrItr = eventsForRetransmission.iterator();
		while (retrItr.hasNext()) {
			Event e = retrItr.next();
			int generationRound = Integer.parseInt(e.eventId.split("_")[2]);
			if (round - generationRound > MAX_AGE_RETRANSMISSION) {
				toBeRemoved.add(e);
			} else if (e.eventId == message.id) {
				toBeSent = e;
			}
		}

		// Send the requested event.
		if (toBeSent != null && USE_RETRANSMISSION) {
			router.send(new SendEventMessage(toBeSent, id), message.sender);
		}

		// Remove the obsolete events.
		eventsForRetransmission.removeAll(toBeRemoved);
	}

	/**
	 * Handles an incoming event that had been requested.
	 * 
	 * The event is added to its sets and delivered.
	 * 
	 * @param message the message containing the event that was previously
	 *                requested.
	 */
	public void receiveRequestedEvent(SendEventMessage message) {
		print("\t" + id + "\tREQUEST:\t" + message.event.eventId);

		if (!eventIds.contains(message.event.eventId)) {
			lpbDelivery(message.event);
		}
	}

	/**
	 * Unsubscribes or re-subscribes probabilistically.
	 * 
	 * At each time step, the node probabilistically unsubs/resubs. If the node
	 * unsubscribes, it communicates it to its view and clears its buffers, since it
	 * won't use them anymore.
	 */
	private void subUnsub() {
		if (USE_UNSUBSCRIPTIONS && isSubbed && random.nextDouble() <= PROBABILITY_UNSUB) {
			isSubbed = false;
			// Communicate unsubscription to the view.
			unSubs.add(id);
			Iterator<Integer> itr = view.iterator();
			GossipMessage gossip = new GossipMessage(events, eventIds, unSubs, subs, id);
			int nSend = NUMBER_GOSSIP_SENDS;
			while (itr.hasNext() && nSend > 0) {
				router.send(gossip, itr.next());
				nSend -= 1;
			}
			// Clear all sets.
			removeNodesFromSet(view, 0);
			removeNodesFromSet(subs, 0);
			removeNodesFromSet(unSubs, 0);
			eventIds = new LinkedList<String>();
			events = new HashSet<Event>();
			retrieveBuf = new HashSet<EventToRetrieve>();

			// Clear the networks.
			clearNetwork("view network");
			clearNetwork("subs network");
			clearNetwork("unsubs network");
			clearNetwork("sentMessages network");
		} else if (!isSubbed && random.nextDouble() <= PROBABILITY_SUB) {
			isSubbed = true;
			// Add a node that is currently subscribed. Such a node is assumed to exist.
			Iterator<Object> itr = space.getObjects().iterator();
			Node neigh = (Node) itr.next();
			while (!neigh.isSubbed) {
				neigh = (Node) itr.next();
			}
			view.add(neigh.id);
		}
	}

	/**
	 * Removes random nodes in order to have a set of maxSize size.
	 * 
	 * @param set     the HashSet containing the nodes.
	 * @param maxSize the maximum size of the set.
	 * @return the HashSet with size maxSize.
	 */
	private HashSet<Integer> removeNodesFromSet(HashSet<Integer> set, int maxSize) {
		ArrayList<Integer> list = new ArrayList<Integer>(set);

		// Keep removing nodes while the set is too big.
		while (list.size() > maxSize) {
			list.remove(random.nextInt(list.size()));
		}

		return new HashSet<Integer>(list);
	}

	/**
	 * Removes the oldest notifications from the buffer.
	 */
	public void removeOldestNotifications() {
		// Sort the events by age.
		List<Event> sorted_events = new ArrayList<Event>(events);
		Collections.sort(sorted_events, (a, b) -> a.age < b.age ? 1 : a.age == b.age ? 0 : -1);

		// Remove out-of-date events.
		int size = sorted_events.size();
		for (int i = 0; i < size; i++) {
			for (int j = size - 1; j >= 0; j--) {
				Event e = sorted_events.get(i);
				Event e1 = sorted_events.get(j);

				// Compare only distinct events.
				if (e != e1) {
					// Compare the age of events from the same sender.
					if (events.size() > MAX_SIZE_EVENTS && e.sender == e1.sender && e.age - e1.age > MAX_AGE_EVENTS) {
						events.remove(e);
						print("***\tRemoved for absolute age:\t" + e.eventId + "\tfrom node\t" + id);
					}
				}
			}
		}

		// Remove the oldest remaining events if the buffer is still full.
		int rem_size = events.size() - MAX_SIZE_EVENTS;
		for (int i = 0; i < rem_size; i++) {
			// Remove an event from the original buffer.
			Event e = sorted_events.get(i);
			events.remove(e);
			print("***\tRemoved for relative age:\t" + e.eventId + "\tfrom node\t" + id);
		}
	}

	/**
	 * Purges the events buffer if it exceeds the maximum size.
	 * 
	 * The removal of events can be random or age-based, depending from the
	 * simulation parameter.
	 */
	private void purgeEvents() {
		if (USE_AGE_BASED_PURGING) {
			// Purge the oldest events.
			removeOldestNotifications();
		} else {
			// Purge random events.
			ArrayList<Event> eventsList = new ArrayList<Event>(events);
			while (eventsList.size() > MAX_SIZE_EVENTS) {
				eventsList.remove(random.nextInt(eventsList.size()));
			}
			events = new HashSet<Event>(eventsList);
		}
	}

	/**
	 * Builds a network creating an edge between the node and every element in the
	 * set.
	 * 
	 * @param set         the target nodes of the edges.
	 * @param networkName the name of the network.
	 */
	private void buildNetwork(HashSet<Integer> set, String networkName) {
		ArrayList<Integer> nodes = new ArrayList<Integer>(set);
		Context<Object> context = ContextUtils.getContext(this);
		Network<Object> net = (Network<Object>) context.getProjection(networkName);

		for (int nodeId : nodes) {
			// find target node
			Node node = null;
			Iterator<Object> itr = space.getObjects().iterator();
			while (node == null && itr.hasNext()) {
				Node next = (Node) itr.next();
				if (next.id == nodeId) {
					node = next;
				}
			}
			net.addEdge(this, node);
		}
	}

	/**
	 * Removes from the network all edges that have the node as source.
	 * 
	 * @param networkName the name of the network.
	 */
	private void clearNetwork(String networkName) {
		Context<Object> context = ContextUtils.getContext(this);
		Network<Object> net = (Network<Object>) context.getProjection(networkName);
		if (net != null) {
			// get node
			Node node = null;
			Iterator<Object> itr = space.getObjects().iterator();
			while (node == null && itr.hasNext()) {
				Node next = (Node) itr.next();
				if (next.id == id) {
					node = next;
				}
			}
			Iterator<RepastEdge<Object>> edges = net.getEdges(node).iterator();
			while (edges.hasNext()) {
				RepastEdge<Object> current = edges.next();
				if (current.getSource().equals(node)) {
					net.removeEdge(current);
				}
			}
		}
	}

	/**
	 * Gets the number of sent messages.
	 * 
	 * @return the number of sent messages.
	 */
	public int getNumberSentMessages() {
		return nMessages;
	}

	/**
	 * Gets the number of delivered messages.
	 * 
	 * @return the number of delivered messages.
	 */
	public int getNumberDeliveredMessages() {
		return nDeliveredMessages;
	}

	/**
	 * Increments the age of every event in the buffer.
	 */
	public void incrementAges() {
		Iterator<Event> itr = events.iterator();
		while (itr.hasNext()) {
			Event e = itr.next();
			e.incrementAge();
		}
	}

	/**
	 * Prints debug information to the console.
	 * 
	 * The flag DEBUG must be enabled; each call prints the text followed by a
	 * newline.
	 */
	public void print(String text) {
		if (DEBUG) {
			System.out.println(text);
		}
	}

	/**
	 * Class used to save an event that exists but has yet to be received by the
	 * node.
	 */
	private class EventToRetrieve {
		String eventId;
		int round;
		int gossipSender;

		/**
		 * Constructor of EventToRetrieve.
		 * 
		 * @param eventId      the id of the event that has yet to be received.
		 * @param round        the round in which the node first discovered the presence
		 *                     of the event.
		 * @param gossipSender the sender of the gossip which contained the eventId.
		 */
		public EventToRetrieve(String eventId, int round, int gossipSender) {
			this.eventId = eventId;
			this.round = round;
			this.gossipSender = gossipSender;
		}
	}
}
